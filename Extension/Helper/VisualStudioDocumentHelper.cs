using System;
using System.Diagnostics;
using System.Linq;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using Community.VisualStudio.Toolkit;
using EnvDTE;
using EnvDTE80;
using Microsoft.CodeAnalysis;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.ComponentModelHost;
using Microsoft.VisualStudio.Editor;
using Microsoft.VisualStudio.Imaging.Interop;
using Microsoft.VisualStudio.LanguageServices;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using IServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;

namespace SyncToAsync.Extension.Helper
{
    public class VisualStudioDocumentHelper
    {
        private readonly string _documentFullPath;

        private readonly IComponentModel _componentModel;
        private readonly IVsUIShellOpenDocument? _openDoc;
        private readonly IVsTextManager? _textManager;
        private readonly DTE2 _dte;
        private readonly ServiceProvider _serviceProvider;
        private readonly IVsInfoBarUIFactory _infoBarFactory;

        public VisualStudioDocumentHelper(
            string documentFullPath
            )
        {
            if (documentFullPath is null)
            {
                throw new ArgumentNullException(nameof(documentFullPath));
            }

            ThreadHelper.ThrowIfNotOnUIThread();

            _documentFullPath = documentFullPath;

            _componentModel = (IComponentModel)Package.GetGlobalService(typeof(SComponentModel));
            _openDoc = Package.GetGlobalService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            _textManager = Package.GetGlobalService(typeof(VsTextManagerClass)) as IVsTextManager;

            _dte = AsyncPackage.GetGlobalService(typeof(EnvDTE.DTE)) as DTE2;
            _serviceProvider = new ServiceProvider((Microsoft.VisualStudio.OLE.Interop.IServiceProvider)_dte);
            _infoBarFactory = (IVsInfoBarUIFactory)_serviceProvider.GetService(typeof(SVsInfoBarUIFactory));
        }

        public void Open(
            )
        {
            ThreadHelper.ThrowIfNotOnUIThread(nameof(Open));

            var logicalView = VSConstants.LOGVIEWID_Code;

            OpenDocument(logicalView, out _);
        }


        //public void OpenNavigateWithInfoBar(
        //    int position,
        //    int length
        //    )
        //{
        //    ThreadHelper.ThrowIfNotOnUIThread(nameof(OpenAndNavigate));

        //    var logicalView = VSConstants.LOGVIEWID_Code;

        //    if (!OpenDocument(logicalView, out IVsWindowFrame? frame))
        //    {
        //        return;
        //    }

        //    // We'll override the window frame and never show it as dirty, even if there's an underlying edit
        //    frame!.SetProperty((int)__VSFPROPID2.VSFPROPID_OverrideDirtyState, false);
        //    frame!.SetProperty((int)__VSFPROPID5.VSFPROPID_OverrideCaption, "[qq generated caption]");
        //    frame!.SetProperty((int)__VSFPROPID5.VSFPROPID_OverrideToolTip, "[qq generated tooltip]");

        //    //add an info bar (gold bar) to the opened document
        //    if (ErrorHandler.Succeeded(
        //        frame.GetProperty((int)__VSFPROPID7.VSFPROPID_InfoBarHost, out var infoBarHostObject)
        //        )
        //        && infoBarHostObject is IVsInfoBarHost infoBarHost
        //        )
        //    {
        //        var infoBar = new InfoBarModel(
        //            $"This file is auto-generated by the source generator and cannot be edited.",
        //            default,
        //            isCloseButtonVisible: false
        //            );
        //        var infoBarUI = _infoBarFactory.CreateInfoBar(infoBar);
        //        infoBarHost.AddInfoBar(infoBarUI);
        //    }

        //    frame!.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out object docData);
        //    if (!GetVsTextBuffer(docData, out VsTextBuffer? vsTextBuffer2))
        //    {
        //        return;
        //    }
        //    var vsTextBuffer = vsTextBuffer2 as IVsTextBuffer;

        //    //var editorAdapterFactoryService = _componentModel.GetService<IVsEditorAdaptersFactoryService>();
        //    //var textBuffer = editorAdapterFactoryService.GetDataBuffer(vsTextBuffer);
        //    //using (var edit = textBuffer.CreateEdit(EditOptions.DefaultMinimalChange, reiteratedVersionNumber: null, editTag: null))
        //    //{
        //    //    // TODO: make the edit in some nicer way than creating a massive string
        //    //    edit.Replace(startPosition: 0, textBuffer.CurrentSnapshot.Length, "generatedSource.ToString()");
        //    //    edit.Apply();
        //    //}

        //    //make the document read only
        //    vsTextBuffer.SetStateFlags(1);

        //    //go to target part of the code
        //    NavigateAndSelect(
        //        vsTextBuffer2!,
        //        position,
        //        length
        //        );
        //}

        public async Task<bool> OpenNavigateViewRoslynInternalsAsync(
            DocumentId documentId,
            int position,
            int length
            )
        {
            var workspace = (Workspace)_componentModel.GetService<VisualStudioWorkspace>();

            var r = await workspace.CurrentSolution.GetSourceGeneratedDocumentAsync(documentId, CancellationToken.None);

            var project = workspace.CurrentSolution.GetProject(documentId.ProjectId);
            var sgDocument = await project.GetDocumentByDocumentIdAsync(documentId);
            //var sgDocument = (await project.GetSourceGeneratedDocumentsAsync(CancellationToken.None)).First(d => d.Id.Equals(documentId));

            var extensions = _componentModel.GetExtensions<Microsoft.CodeAnalysis.Host.IWorkspaceService>().ToList();
            var visualStudioDocumentNavigationService = extensions.Find(s => s.GetType().Name == "VisualStudioDocumentNavigationService");
            var visualStudioDocumentNavigationServiceType = visualStudioDocumentNavigationService.GetType();
            var getLocationForSpanAsyncMethod = visualStudioDocumentNavigationServiceType.GetMethod("GetLocationForSpanAsync");
            var getLocationForSpanAsyncTask = (Task)getLocationForSpanAsyncMethod.Invoke(
                visualStudioDocumentNavigationService,
                new object[]
                {
                    workspace,
                    sgDocument.Id,
                    new Microsoft.CodeAnalysis.Text.TextSpan(
                        position,
                        0 //length
                        ),
                    true, //allowInvalidSpan
                    CancellationToken.None
                }
                );
            await getLocationForSpanAsyncTask;

            var navigableLocation = getLocationForSpanAsyncTask.GetType().GetProperty("Result").GetValue(getLocationForSpanAsyncTask);

            var navigateOptionsType = navigableLocation.GetType().Assembly.GetType("Microsoft.CodeAnalysis.Navigation.NavigationOptions");
            var navigateOptions = navigateOptionsType.GetConstructor(new Type[0]).Invoke(new object[0]);

            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(CancellationToken.None);

            var navigateToAsyncMethod = navigableLocation.GetType().GetMethod("NavigateToAsync");
            var navigateToAsyncMethodTask = (Task)navigateToAsyncMethod.Invoke(
                navigableLocation,
                new object[]
                {
                    navigateOptions,
                    CancellationToken.None
                });
            await navigateToAsyncMethodTask;
            var navigateToAsyncMethodSuccess = (bool)navigateToAsyncMethodTask.GetType().GetProperty("Result").GetValue(navigateToAsyncMethodTask);
            return navigateToAsyncMethodSuccess;
        }

        public void OpenNavigate(
            int position,
            int length
            )
        {
            ThreadHelper.ThrowIfNotOnUIThread(nameof(OpenAndNavigate));

            var logicalView = VSConstants.LOGVIEWID_Code;

            if (!OpenDocument(logicalView, out IVsWindowFrame? frame))
            {
                return;
            }

            frame!.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out object docData);
            if (!GetVsTextBuffer(docData, out VsTextBuffer? vsTextBuffer2))
            {
                return;
            }

            //go to target part of the code
            NavigateAndSelect(
                vsTextBuffer2!,
                position,
                length
                );
        }

        public void OpenAndNavigate(
            int startLine,
            int startColumn,
            int endLine,
            int endColumn
            )
        {
            ThreadHelper.ThrowIfNotOnUIThread(nameof(OpenAndNavigate));

            var logicalView = VSConstants.LOGVIEWID_Code;

            if (!OpenDocument(logicalView, out IVsWindowFrame? frame))
            {
                return;
            }

            frame!.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out object docData);

            if (!GetVsTextBuffer(docData, out VsTextBuffer? buffer))
            {
                return;
            }

            NavigateAndSelect(
                buffer!,
                startLine, 
                startColumn, 
                endLine, 
                endColumn
                );
        }

        private void NavigateAndSelect(
            VsTextBuffer buffer,
            int position,
            int length
            )
        {
            if (_textManager == null)
            {
                return;
            }

            var docViewType = default(Guid);

            _textManager.NavigateToPosition(
                buffer,
                ref docViewType,
                position,
                length
                );
        }

        private void NavigateAndSelect(
            VsTextBuffer buffer,
            int startLine,
            int startColumn,
            int endLine,
            int endColumn
            )
        {
            if (_textManager == null)
            {
                return;
            }

            var docViewType = default(Guid);

            _textManager.NavigateToLineAndColumn(
                buffer,
                ref docViewType,
                startLine,
                startColumn,
                endLine,
                endColumn
                );
        }

        private static bool GetVsTextBuffer(
            object docData,
            out VsTextBuffer? buffer
            )
        {
            // Get the VsTextBuffer  
            buffer = docData as VsTextBuffer;
            if (buffer == null)
            {
                if (docData is IVsTextBufferProvider bufferProvider)
                {
                    ErrorHandler.ThrowOnFailure(
                        bufferProvider.GetTextBuffer(out IVsTextLines lines)
                        );

                    buffer = lines as VsTextBuffer;

                    Debug.Assert(buffer != null, "IVsTextLines does not implement IVsTextBuffer");

                    if (buffer == null)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        private bool OpenDocument(
            Guid logicalView,
            out IVsWindowFrame? frame
            )
        {
            if (_openDoc is null)
            {
                frame = null;
                return false;
            }

            if (ErrorHandler.Failed(
                    _openDoc.OpenDocumentViaProject(
                        _documentFullPath,
                        ref logicalView,
                        out IServiceProvider _,
                        out IVsUIHierarchy hier,
                        out var itemId,
                        out frame)
                    ) ||
                frame == null)
            {
                return false;
            }

            return true;
        }
    }
}
